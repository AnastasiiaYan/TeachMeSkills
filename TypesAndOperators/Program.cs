**bool * *: хранит значение true или false (логические литералы). Представлен системным типом System.Boolean

bool alive = true;
bool isDead = false;

**byte * *: хранит целое число от 0 до 255 и занимает 1 байт. Представлен системным типом System.Byte
byte bit1 = 1;
byte bit2 = 102;

**sbyte * *: хранит целое число от -128 до 127 и занимает 1 байт. Представлен системным типом System.SByte
sbyte bit1 = -101;
sbyte bit2 = 102;

**short * *: хранит целое число от -32768 до 32767 и занимает 2 байта. Представлен системным типом System.Int16
short n1 = -1;
short n2 = 102;

**ushort * *: хранит целое число от 0 до 65535 и занимает 2 байта. Представлен системным типом System.UInt16
ushort n1 = 1;
ushort n2 = 102;

**int * *: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта. Представлен системным типом System.Int32. Все целочисленные литералы по умолчанию представляют значения типа int:
int a = 10;
int b = 0b101;  // бинарная форма b =5
int c = 0xFF;   // шестнадцатеричная форма c = 255

**uint * *: хранит целое число от 0 до 4294967295 и занимает 4 байта. Представлен системным типом System.UInt32
uint a = 10;
uint b = 0b101;
uint c = 0xFF;

**long * *: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт. Представлен системным типом System.Int64
long a = -10;
long b = 0b101;
long c = 0xFF;

**ulong * *: хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт. Представлен системным типом System.UInt64
ulong a = 10;
ulong b = 0b101;
ulong c = 0xFF;

**float * *: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта. Представлен системным типом System.Single

**double**: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта. Представлен системным типом System.Double

**decimal**: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10-28 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом System.Decimal

**char**: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы:char a = 'A';
char b = '\x5A';
char c = '\u0420';

**string * *: хранит набор символов Unicode. Представлен системным типом System.String. Этому типу соответствуют строковые литералы.
string hello = "Hello";
string word = "world";

**object * *: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET.

object a = 22;
object b = 3.14;
object c = "hello code";

**Использование суффиксов**
При присвоении значений надо иметь в виду следующую тонкость: все вещественные литералы (дробные числа) рассматриваются как значения типа double. И чтобы указать, что дробное число представляет тип float или тип decimal, необходимо к литералу добавлять суффикс: F / f - для float и M/m - для decimal.

float a = 3.14F;

float b = 30.6f;

decimal c = 1005.8M;

decimal d = 334.8m;

Подобным образом все целочисленные литералы рассматриваются как значения типа int. Чтобы явным образом указать, что целочисленный литерал представляет значение типа uint, надо использовать суффикс U/u, для типа long - суффикс L/l, а для типа ulong - суффикс UL/ul:

uint a = 10U;
long b = 20L;
ulong c = 30UL;

var f = 0f; // float
var d = 0d; // double
var m = 0m; // decimal (money)
var u = 0u; // unsigned int
var l = 0l; // long
var ul = 0ul; // unsigned long

**Неявная типизация.* *
var hello = "Hell to World";
var c = 20;

Для неявной типизации вместо названия типа данных используется ключевое слово var. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения.

***Ограничения.***
1. Нельзя сначала объявить неявно типизируемую переменную, а затем инициализировать:
var c; c = 20; // этот код не работает

2.Нельзя  указать в качестве значения неявно типизируемой переменной null:

var c = null; // этот код не работает

**Приведение к типу:**
Convert.ToInt32()(преобразует к типу int)
Convert.ToDouble()(преобразует к типу double)

Convert.ToDecimal()(преобразует к типу decimal)

Console.Write("Введите возраст: ");
**int age = Convert.ToInt32(Console.ReadLine()); **

Console.Write("Введите рост: ");
double height = Convert.ToDouble(Console.ReadLine());

Console.Write("Введите размер зарплаты: ");
decimal salary = Convert.ToDecimal(Console.ReadLine());

**Преобразования базовых типов данных.**

**(тип_данных_в_который_надо_преобразовать)значение_для_преобразования; **

byte a = 4;
byte b = a + 70;  // ошибка

byte a = 4;
byte b = (byte)(a + 70); // корректно

Операция сложения /вычитания возвращает значение типа **int**, если в операции участвуют целочисленные типы данных с разрядностью меньше или равно int (то есть типы byte, short, int). Поэтому результатом операции a + 70 будет *объект, который имеет длину в памяти 4 байта*. Затем этот объект мы пытаемся присвоить переменной *b, которая имеет тип byte и в памяти занимает 1 байт.*

Мы можем точно не знать, какие значения будут иметь числа a и b. И чтобы избежать подобных ситуаций, в c# имеется ключевое слово checked:

try
{
int a = 33;
int b = 600;
byte c = checked((byte)(a + b));
Console.WriteLine(c);
}
catch (OverflowException ex)
{
    Console.WriteLine(ex.Message);
}

***При использовании ключевого слова checked приложение выбрасывает исключение о переполнении***. Поэтому для его обработки в данном случае используется конструкция try...catch. Подробнее данную конструкцию и обработку исключений мы рассмотрим позже, а пока надо знать, что в блок try мы включаем действия, в которых может потенциально возникнуть ошибка, а в блоке catch обрабатываем ошибку.

# Операции

Приоритет операций от наивысшего к низшему:
1.Инкремент, декремент
2.Умножение, деление, получение остатка
3. Сложение, вычитание

Все арифметические операторы являются **левоассоциативными, то есть выполняются слева направо.** Поэтому выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) *2, то есть результатом будет 4.

При делении: если оба операнда представляют целые числа, то результат также будет округляться до целого числа:
double z = 10 / 4; //результат равен 2
Несмотря на то, что результат операции в итоге помещается в переменную типа double, которая позволяет сохранить дробную часть, но **в самой операции участвуют два литерала, которые по умолчанию рассматриваются как объекты int, то есть целые числа, и результат то же будет целочисленный.**

Для выхода из этой ситуации необходимо определять литералы или переменные, участвующие в операции, именно как типы double или float:
double z = 10.0 / 4.0; //результат равен 2.5

% получение остатка от целочисленного деления
double x = 10.0;
double z = x % 4.0; //результат равен 2

**Операция инкремента**
префиксный: ++x

int x1 = 5;
int** z1 = ++x1; // z1=6**; x1=6

постфиксный: x++
int x2 = 5;
int** z2 = x2++; // z2=5**; x2=6

**Операция декремента**
префиксный: - -x

int x1 = 5;
int** z1 = --x1; // z1=4**; x1=4

постфиксный: x - -

int x2 = 5;
int** z2 = x2--; // z2=5;** x2=4

Постфиксный декремент: сначалла операция выполняется с неизмененным числом, лишь затем он меняется.
int d = 40 - 5*3 = 25

int a = 3;
int b = 5;
**int c = 40; **
**int d = c-- - b * a; **    // a=3  b=5  **c=39**  **d=25**

Значение переменной меняется прямо внутри операции

int x = 2;
x = x++ + ++x + ++x;
//х = 2 + 4 + 5 = 11;

ПРИСВОЕНИЕ

* *+=:**присваивание после сложения.Присваивает левому операнду сумму левого и правого операндов.
Выражение** A += B** равнозначно выражению A **= A + B**
Аналогично для других операций, например: **%=:** присваивание после деления по модулю.
 ** A %= B** эквивалентно **A = A % B * *

**int a = 10;
a += 10;        // 20
a -= 4;         // 16
a *= 2;         // 32
a /= 8;         // 4
a <<= 4;      // 64
a >>= 2;      // 16**

Операции присвоения являются правоассоциативными, то есть выполняются справа налево. Например:
int a = 8;
int b = 6;
int c = a += b -= 5;    // 9

В данном случае выполнение выражения будет идти следующим образом:
b -= 5 * **ЭТО * **6 - 5 = 1

a += (b -= 5) * **ЭТО * **8 + 1 = 9

c = (a += (b -= 5)) * **ЭТО * **посчитали выше - 9